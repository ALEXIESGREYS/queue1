#include "List2Abstract.h"
struct Uzel {
    void* data;
    Uzel* next;
    Uzel* back;
    size_t size;
};

class List2:public AbstractList2 {
private:
    Uzel* head;
    Uzel* teil;
    // добивим поле count что бы придобавлении увеличивал и обратно
    int count;
    size_t busy_plase;

public:
    List2(MemoryManager& mem) : AbstractList2(mem) {
        head = NULL;
        teil = NULL;
        count = 0;// добавление счетчика
        busy_plase = 0;// для просмотра сколько памяти у нас занято
    }
    ~List2() {}

    int push_back(void* elem, size_t elemSize);

    // Добавление элемента в начало контейнера.
    // В случае успешного добавления функция возвращает значение 0, в случае неудачи 1.
    int push_front(void* elem, size_t elemSize);

    // Удаление элемента из конца контейнера.
    void pop_back();

    // Удаление элемента из начала контейнера.
    void pop_front();

    // Функция явно возвращает указатель на элемент, находящийся в начале контейнера.
    // и не явно возвращает размер данных
    void* front(size_t& size);

    // Функция явно возвращает указатель на элемент, находящийся в конеце контейнера.
    // и не явно возвращает размер данных
    void* back(size_t& size);

    // Добавление элемента в позицию, на которую указывает итератор iter.
    // В случае успешного добавления функция возвращает значение 0, в случае неудачи 1.
    int insert(Iterator* iter, void* elem, size_t elemSize);

    //для счетчика 
    int size();

    // Функция возвращает значение, равное максимальной вместимости контейнера в байтах.
    size_t max_bytes();

    // Функция создает в динамической памяти итератор, указывающий на первый найденный
    // в контейнере элемент. Если элемент не найден, возвращается пустой указатель.
    // Удаление этого итератора должно делаться пользователем с помощью оператора delete.
    Iterator* find(void* elem, size_t size);

    // Функция создает в динамической памяти итератор, указывающий на первый элемент
    // контейнера. Если контейнер пустой, возвращается нулевой указатель.
    // Удаление этого итератора должно делаться пользователем с помощью оператора delete.
    Iterator* newIterator();

    // Удаление элемента из позиции, на которую указывает итератор iter.
    // После удаления итератор указывает на следующий за удаленным элемент.
    void remove(Iterator* iter);

    // Удаление всех элементов из контейнера.
    void clear();

    // Если контейнер пуст возвращает true, иначе false
    bool empty();
};

class Iterator_for_list: public Container::Iterator
{
public:
    Iterator_for_list(Uzel* uzel) : this_uzel(uzel) {}
    ~Iterator_for_list() {}


    // Возврашает явно указатель на элемент, на который указывает итератор в данный момент.
    // Неявно возвращает размер данных.
    // Если итератор показывает за пределы контейнера (например, удален последний элемент), возвращает NULL.
    void* getElement(size_t& size);

    // Возвращает true, если есть следующий элемент, иначе false.
    bool hasNext();

    // Переход к следующему элементу.
    void goToNext();

    // проверка на равенство итераторов
    bool equals(Iterator* right);

    // сообраемт информацию о коробочке
    Uzel* current_uzel();

    private: 
        Uzel* this_uzel = nullptr;
};