#include "QueueAbstract.h"
#include "List2.h"
#include "Mem.h"

class Queue : public AbstractQueue{
public :
    Queue(MemoryManager& mem) : AbstractQueue(mem) {
        list2_ = new List2(mem);
    }
	~Queue() {}

    // Добавление элемента в конец контейнера. В случае успешного добавления функция возвращает значение 0, в случае неудачи 1.
    int push(void* elem, size_t size);

    // Удаление элемента из начала контейнера. В случае успешного удаление функция возвращает значение 0, в случае неудачи 1.
    int pop();

    // Функция явно возвращает указатель на элемент, находящийся в начале контейнера.
    // и не явно возвращает размер данных
    void* front(size_t& size);

    // Функция явно возвращает указатель на элемент, находящийся в конце контейнера.
    // и неявно возвращает размер данных
    void* back(size_t& size);

    // Добавление элемента в позицию, на которую указывает итератор iter.
    // В случае успешного добавления функция возвращает значение 0, в случае неудачи 1.
    int insert(Iterator* iter, void* elem, size_t size);

    //для счетчика 
    int size();

    // Функция возвращает значение, равное максимальной вместимости контейнера в байтах.
    size_t max_bytes();

    // Функция создает в динамической памяти итератор, указывающий на первый найденный
    // в контейнере элемент. Если элемент не найден, возвращается пустой указатель.
    // Удаление этого итератора должно делаться пользователем с помощью оператора delete.
    Iterator* find(void* elem, size_t size);

    // Функция создает в динамической памяти итератор, указывающий на первый элемент
    // контейнера. Если контейнер пустой, возвращается нулевой указатель.
    // Удаление этого итератора должно делаться пользователем с помощью оператора delete.
    Iterator* newIterator();

    // Удаление элемента из позиции, на которую указывает итератор iter.
    // После удаления итератор указывает на следующий за удаленным элемент.
    void remove(Iterator* iter);

    // Удаление всех элементов из контейнера.
    void clear();

    // Если контейнер пуст возвращает true, иначе false
    bool empty();


    class QueueIterator
    {
    public:
        QueueIterator(Queue* que) {
            list2_ = que->get_list2_();
            iterator = (Iterator_for_list*)(list2_->newIterator());
        }
        ~QueueIterator() {}
        // Возврашает явно указатель на элемент, на который указывает итератор в данный момент.
        // Неявно возвращает размер данных.
        // Если итератор показывает за пределы контейнера (например, удален последний элемент), возвращает NULL.
        void* getElement(size_t& size);

        // Возвращает true, если есть следующий элемент, иначе false.
        bool hasNext();

        void goToNext();

        bool equals(Iterator* right);

        Iterator_for_list* getListIterator() { return iterator; }
    private:
        List2* list2_ = NULL;
        Iterator_for_list* iterator = NULL;
    };

private:
    List2* list2_ = NULL;
public:
    List2* get_list2_() {
        return list2_;
    }
};